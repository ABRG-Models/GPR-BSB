


/*
   Autogenerated BRAHMS process from SpineML description.
   Engine: XSLT
   Engine Author: Alex Cope 2012
   Node name: Background to D1 MSN Synapse 0 postsynapse
*/


#define COMPONENT_CLASS_STRING "dev/SpineML/temp/PS/AMPAbuf"
#define COMPONENT_CLASS_CPP dev_spineml_ps_AMPAbuf_0
#define COMPONENT_RELEASE 0
#define COMPONENT_REVISION 1
#define COMPONENT_ADDITIONAL "Author=SpineML_2_BRAHMS\n" "URL=Not supplied\n"
#define COMPONENT_FLAGS (F_NOT_RATE_CHANGER)

#define OVERLAY_QUICKSTART_PROCESS

//	include the component interface overlay (component bindings 1199)
#include "brahms-1199.h"

//	alias data and util namespaces to something briefer
namespace numeric = std_2009_data_numeric_0;
namespace spikes = std_2009_data_spikes_0;
namespace rng = std_2009_util_rng_0;

using namespace std;

#include "rng.h"
// Some very SpineML_2_BRAHMS specific defines, common to all components.
#define randomUniform     _randomUniform(&this->rngData_BRAHMS)
#define randomNormal      _randomNormal(&this->rngData_BRAHMS)
#define randomExponential _randomExponential(&this->rngData_BRAHMS)
#define randomPoisson     _randomPoisson(&this->rngData_BRAHMS)
#include "impulse.h"

/* helper function for doing the indexing... do we need this?
int getIndex(VDOUBLE position, VDOUBLE size) {

	int index = 0;
	int mult = 1;
	for (int i = 0; i < size.size(); ++i) {
		index = index + pos[i] * mult;
		mult = mult * size[i];
	}

}*/

// structure allowing weights to be sent with spikes
struct INT32SINGLE {
	INT32 i;
	SINGLE s;
};

float dt;

class COMPONENT_CLASS_CPP;


//TimeDerivative
float (COMPONENT_CLASS_CPP::*  CurrentP__Pg_ampa)(float, int);


////////////////	COMPONENT CLASS (DERIVES FROM Process)

class COMPONENT_CLASS_CPP : public Process
{

public:

	//	use ctor/dtor only if required
	COMPONENT_CLASS_CPP() {}
	~COMPONENT_CLASS_CPP() {}

	//	the framework event function
	Symbol event(Event* event);

private:

// Some data for the random number generator.
RngData rngData_BRAHMS;

float t;

// base name
string baseNameForLogs_BRAHMS;

// model directory string
string modelDirectory_BRAHMS;

// Determine if this weight update component has only FixedValue Parameters and
// FixedValue delays. Initialised to true; may be set false. If it remains true,
// then AllToAll connectivity may be optimised.
bool allParamsDelaysAreFixedValue;

// define regimes

#define AMPAbufX__XCurrent 1


// Global variables
vector < int > AMPAbufO__Oregime;
vector < int > AMPAbufO__OregimeNext;


VDOUBLE size_BRAHMS;
int numElements_BRAHMS;

// Analog Ports

vector < numeric::Input > PORTv;
vector < double > v;

numeric::Output PORTI_ampa;
//if using an alias then create the output variable

vector < double > I_ampa;

vector < double > I_ampaLOGVAR;
vector < int > I_ampaLOGMAP;
FILE * I_ampaLOGFILE;

numeric::Output PORTg_ampa;
//if using an alias then create the output variable

vector < double > g_ampaLOGVAR;
vector < int > g_ampaLOGMAP;
FILE * g_ampaLOGFILE;


// Event Ports


// Impulse Ports

vector < spikes::Input > PORTS;
vector < DOUBLE > S;


// State Variables

	vector <  double > g_ampa;
	string g_ampa_BINARY_FILE_NAME;
	string g_ampa_BINARY_FILE_NAME_OUT;
	vector <  double > buffer;
	string buffer_BINARY_FILE_NAME;
	string buffer_BINARY_FILE_NAME_OUT;

// Parameters

	vector < double > tau_ampa;

	vector < double > E_ampa;

	vector < double > g_bar;

	vector < double > buffer_max;


// Add aliases that are not inputs

//TimeDerivative
float CurrentV__Vg_ampa(float val_BRAHMS, int num_BRAHMS) {
float return_val_BRAHMS;
g_ampa[num_BRAHMS] = val_BRAHMS;
return_val_BRAHMS = -g_ampa[num_BRAHMS]/tau_ampa[num_BRAHMS];
return return_val_BRAHMS;
}
//float (*  CurrentP__Pg_ampa)(float val_BRAHMS, int num_BRAHMS);


// forward euler
float integrate(float x, float (COMPONENT_CLASS_CPP::*func)(float, int), int num) {

	return x + (*this.*func)(x,num)*dt;

}
/*
// Runge Kutta 4th order
float integrate(float x, float (COMPONENT_CLASS_CPP::*func)(float, int), int num) {

	float k1 = dt*(*this.*func)(x,num);
	float k2 = dt*(*this.*func)(x+0.5*k1,num);
	float k3 = dt*(*this.*func)(x+0.5*k2,num);
	float k4 = dt*(*this.*func)(x+k3,num);
	return x + (1.0/6.0)*(k1 + 2.0*k2 + 2.0*k3 + k4);

}*/

};

////////////////	EVENT

Symbol COMPONENT_CLASS_CPP::event(Event* event)
{
	switch(event->type)
	{
		case EVENT_STATE_SET:
		{
			// Initialise allParamsDelaysAreFixedValue to false as this only pertains to weight components
			this->allParamsDelaysAreFixedValue = false;

			//	extract DataML
			EventStateSet* data = (EventStateSet*) event->data;
			XMLNode xmlNode(data->state);
			DataMLNode nodeState(&xmlNode);

			// obtain the parameters
			size_BRAHMS = nodeState.getField("size").getArrayDOUBLE();
			numElements_BRAHMS = 1;
			for (int i = 0; i < size_BRAHMS.size(); ++i) {
				numElements_BRAHMS *= size_BRAHMS[i];
			}

			// Ensure field is present (trigger BRAHMS error if not)
			modelDirectory_BRAHMS = nodeState.getField("model_directory").getSTRING();

			rngDataInit(&this->rngData_BRAHMS);
			zigset(&this->rngData_BRAHMS, 11);


			int numEl_BRAHMS = numElements_BRAHMS;

			// State Variables


			// Any state variable means that we can't optimise alltoall weight update components:
			this->allParamsDelaysAreFixedValue = false;
			{
			bool finishedThis = false;
			// see if not there at all (if so initialise to zero)
			if (!(nodeState.hasField("g_ampaRANDXOVER2") || \
				nodeState.hasField("g_ampaOVER2") || \
				nodeState.hasField("g_ampaRANDX") || \
				nodeState.hasField("g_ampa") || \
				nodeState.hasField("g_ampaOVER1") || \
				nodeState.hasField("g_ampaBIN_FILE_NAME"))) {
				g_ampa.resize(numEl_BRAHMS, 0);
			}

			if (nodeState.hasField("g_ampaRANDXOVER2")) {
				g_ampa = nodeState.getField("g_ampaRANDXOVER2").getArrayDOUBLE();
				float val1_BRAHMS = 0;
				float val2_BRAHMS = 1;
				// if normal distribution
				if (g_ampa[0] == 1) {
					val1_BRAHMS = g_ampa[1];
					val2_BRAHMS = g_ampa[2];
					this->rngData_BRAHMS.seed = g_ampa[3];
					if (this->rngData_BRAHMS.seed == 0)
						this->rngData_BRAHMS.seed = getTime();
					g_ampa.resize(numEl_BRAHMS, 0);
					for (UINT32 i_BRAHMS = 0; i_BRAHMS < numEl_BRAHMS; ++i_BRAHMS) {
						g_ampa[i_BRAHMS] = (RNOR(&this->rngData_BRAHMS) * val2_BRAHMS) + val1_BRAHMS;
					}
				}
				// if uniform distribution
				if (g_ampa[0] == 2) {
					val1_BRAHMS = g_ampa[1];
					val2_BRAHMS = g_ampa[2];
					this->rngData_BRAHMS.seed = g_ampa[3];
					if (this->rngData_BRAHMS.seed == 0)
						this->rngData_BRAHMS.seed = getTime();
					g_ampa.resize(numEl_BRAHMS, 0);
					for (UINT32 i_BRAHMS = 0; i_BRAHMS < numEl_BRAHMS; ++i_BRAHMS) {
						g_ampa[i_BRAHMS] = (UNI(&this->rngData_BRAHMS) * (val2_BRAHMS-val1_BRAHMS)) + val1_BRAHMS;
					}
				}
				finishedThis = true;
			}
			if (nodeState.hasField("g_ampaOVER2") && !finishedThis) {
				if (nodeState.getField("g_ampaOVER2").getDims()[0] == 1) {g_ampa = nodeState.getField("g_ampaOVER2").getArrayDOUBLE();
					if (g_ampa.size() == 1) {
						g_ampa.resize(numEl_BRAHMS, g_ampa[0]);
					} else if (g_ampa.size() != numEl_BRAHMS) {
						berr << "State Variable g_ampa has incorrect dimensions (Its size is " << g_ampa.size() << ", not " << numEl_BRAHMS << ")";
					}
					finishedThis = true;
				}
			}

			if (nodeState.hasField("g_ampaRANDX") && !finishedThis) {

				g_ampa = nodeState.getField("g_ampaRANDX").getArrayDOUBLE();
				float val1_BRAHMS = 0;
				float val2_BRAHMS = 1;
				// if normal distribution
				if (g_ampa[0] == 1) {
					val1_BRAHMS = g_ampa[1];
					val2_BRAHMS = g_ampa[2];
					this->rngData_BRAHMS.seed = g_ampa[3];
					if (this->rngData_BRAHMS.seed == 0)
						this->rngData_BRAHMS.seed = getTime();
					g_ampa.resize(numEl_BRAHMS, 0);
					for (UINT32 i_BRAHMS = 0; i_BRAHMS < numEl_BRAHMS; ++i_BRAHMS) {
						g_ampa[i_BRAHMS] = (RNOR(&this->rngData_BRAHMS) * val2_BRAHMS) + val1_BRAHMS;
					}
				}
				// if uniform distribution
				if (g_ampa[0] == 2) {
					val1_BRAHMS = g_ampa[1];
					val2_BRAHMS = g_ampa[2];
					this->rngData_BRAHMS.seed = g_ampa[3];
					if (this->rngData_BRAHMS.seed == 0)
						this->rngData_BRAHMS.seed = getTime();
					g_ampa.resize(numEl_BRAHMS, 0);
					for (UINT32 i_BRAHMS = 0; i_BRAHMS < numEl_BRAHMS; ++i_BRAHMS) {
						g_ampa[i_BRAHMS] = (UNI(&this->rngData_BRAHMS) * (val2_BRAHMS-val1_BRAHMS)) + val1_BRAHMS;
					}
				}
			}

			if (nodeState.hasField("g_ampa") && !finishedThis) {
			g_ampa = nodeState.getField("g_ampa").getArrayDOUBLE();
				if (g_ampa.size() == 1) {
					g_ampa.resize(numEl_BRAHMS, g_ampa[0]);
				} else if (g_ampa.size() != numEl_BRAHMS) {
					berr << "State Variable g_ampa has incorrect dimensions (Its size is " << g_ampa.size() << ", not " << numEl_BRAHMS << ")";
				}
			}

			if (nodeState.hasField("g_ampaBIN_FILE_NAME") && !finishedThis) {
			        if (!nodeState.hasField("g_ampaBIN_NUM_ELEMENTS")) {
				        berr << "Found a binary file name without corresponding binary number of elements.";
				}
				g_ampa_BINARY_FILE_NAME = nodeState.getField("g_ampaBIN_FILE_NAME").getSTRING();
				int __temp_num_property_elements = nodeState.getField("g_ampaBIN_NUM_ELEMENTS").getINT32();

				// open the file for reading
				FILE * binfile;

				string fileName = modelDirectory_BRAHMS + "/" + g_ampa_BINARY_FILE_NAME;
				binfile = fopen(fileName.c_str(),"rb");
				if (!binfile) {
					berr << "Could not open properties list file: " << fileName;
				}

				g_ampa.resize(__temp_num_property_elements);
				vector<INT32> __temp_property_list_indices (__temp_num_property_elements, 0);
				vector<DOUBLE> __temp_property_list_values (__temp_num_property_elements, 0);
				for (int i_BRAHMS = 0; i_BRAHMS < __temp_num_property_elements; ++i_BRAHMS) {

					size_t ret_FOR_BRAHMS = fread(&__temp_property_list_indices[i_BRAHMS], sizeof(INT32), 1, binfile);
					if (ret_FOR_BRAHMS == -1) {berr << "Error loading binary properties: Failed to read an index";}
					ret_FOR_BRAHMS = fread(&__temp_property_list_values[i_BRAHMS], sizeof(DOUBLE), 1, binfile);
					if (ret_FOR_BRAHMS == -1) {berr << "Error loading binary properties: Failed to read a value";}
				}
				for (int i_BRAHMS = 0; i_BRAHMS < __temp_num_property_elements; ++i_BRAHMS) {
				        if ( __temp_property_list_indices[i_BRAHMS] > __temp_num_property_elements
					    || __temp_property_list_indices[i_BRAHMS] < 0) {
					    berr << "Error loading binary state variable property g_ampa: index "
						 << __temp_property_list_indices[i_BRAHMS] << " out of range";
					}
					g_ampa[__temp_property_list_indices[i_BRAHMS]] = __temp_property_list_values[i_BRAHMS];
				}
			}


			if (nodeState.hasField("g_ampaOVER1") && !finishedThis)
			{
				vector < double > __tempInputValues__;
				__tempInputValues__ = nodeState.getField("g_ampaOVER1").getArrayDOUBLE();
				// since OVER1 always means sparse Values
				if (g_ampa.size() == 1) {g_ampa.resize(numEl_BRAHMS, g_ampa[0]);
				}
				if (g_ampa.size() != numEl_BRAHMS) {berr << "State Variable g_ampa has a ValueList override but no base Values";}
				for (UINT32 i_BRAHMS = 0; i_BRAHMS < __tempInputValues__.size(); i_BRAHMS += 2) {
					if (__tempInputValues__[i_BRAHMS] > numEl_BRAHMS-1) {berr << "State Variable g_ampa has ValueList index " << float(i_BRAHMS)<< " (value of " << float(__tempInputValues__[i_BRAHMS]) << ") out of range";}
					g_ampa[__tempInputValues__[i_BRAHMS]] = __tempInputValues__[i_BRAHMS+1];
				}

			}

			if (nodeState.hasField("g_ampaOVER2") && !finishedThis)
			{
				vector < double > __tempInputValues__;
				__tempInputValues__ = nodeState.getField("g_ampaOVER2").getArrayDOUBLE();
				// OVER2 here means sparse Values
				if (g_ampa.size() != numEl_BRAHMS) {berr << "Experiment State Variable g_ampa has a ValueList override but no base Values";}
				for (UINT32 i_BRAHMS = 0; i_BRAHMS < __tempInputValues__.size(); i_BRAHMS += 2) {
					if (__tempInputValues__[i_BRAHMS] > numEl_BRAHMS-1) {berr << "Experiment State Variable g_ampa has ValueList index " << float(i_BRAHMS)<< " (value of " << float(__tempInputValues__[i_BRAHMS]) << ") out of range";}
					g_ampa[__tempInputValues__[i_BRAHMS]] = __tempInputValues__[i_BRAHMS+1];
				}

			}

			// output the values:
			/*bout << "g_ampa" << D_WARN;
			for (UINT32 i_BRAHMS = 0; i_BRAHMS < g_ampa.size(); ++i_BRAHMS) {
				bout << float(g_ampa[i_BRAHMS]) << D_WARN;
			}*/
			}


			// Any state variable means that we can't optimise alltoall weight update components:
			this->allParamsDelaysAreFixedValue = false;
			{
			bool finishedThis = false;
			// see if not there at all (if so initialise to zero)
			if (!(nodeState.hasField("bufferRANDXOVER2") || \
				nodeState.hasField("bufferOVER2") || \
				nodeState.hasField("bufferRANDX") || \
				nodeState.hasField("buffer") || \
				nodeState.hasField("bufferOVER1") || \
				nodeState.hasField("bufferBIN_FILE_NAME"))) {
				buffer.resize(numEl_BRAHMS, 0);
			}

			if (nodeState.hasField("bufferRANDXOVER2")) {
				buffer = nodeState.getField("bufferRANDXOVER2").getArrayDOUBLE();
				float val1_BRAHMS = 0;
				float val2_BRAHMS = 1;
				// if normal distribution
				if (buffer[0] == 1) {
					val1_BRAHMS = buffer[1];
					val2_BRAHMS = buffer[2];
					this->rngData_BRAHMS.seed = buffer[3];
					if (this->rngData_BRAHMS.seed == 0)
						this->rngData_BRAHMS.seed = getTime();
					buffer.resize(numEl_BRAHMS, 0);
					for (UINT32 i_BRAHMS = 0; i_BRAHMS < numEl_BRAHMS; ++i_BRAHMS) {
						buffer[i_BRAHMS] = (RNOR(&this->rngData_BRAHMS) * val2_BRAHMS) + val1_BRAHMS;
					}
				}
				// if uniform distribution
				if (buffer[0] == 2) {
					val1_BRAHMS = buffer[1];
					val2_BRAHMS = buffer[2];
					this->rngData_BRAHMS.seed = buffer[3];
					if (this->rngData_BRAHMS.seed == 0)
						this->rngData_BRAHMS.seed = getTime();
					buffer.resize(numEl_BRAHMS, 0);
					for (UINT32 i_BRAHMS = 0; i_BRAHMS < numEl_BRAHMS; ++i_BRAHMS) {
						buffer[i_BRAHMS] = (UNI(&this->rngData_BRAHMS) * (val2_BRAHMS-val1_BRAHMS)) + val1_BRAHMS;
					}
				}
				finishedThis = true;
			}
			if (nodeState.hasField("bufferOVER2") && !finishedThis) {
				if (nodeState.getField("bufferOVER2").getDims()[0] == 1) {buffer = nodeState.getField("bufferOVER2").getArrayDOUBLE();
					if (buffer.size() == 1) {
						buffer.resize(numEl_BRAHMS, buffer[0]);
					} else if (buffer.size() != numEl_BRAHMS) {
						berr << "State Variable buffer has incorrect dimensions (Its size is " << buffer.size() << ", not " << numEl_BRAHMS << ")";
					}
					finishedThis = true;
				}
			}

			if (nodeState.hasField("bufferRANDX") && !finishedThis) {

				buffer = nodeState.getField("bufferRANDX").getArrayDOUBLE();
				float val1_BRAHMS = 0;
				float val2_BRAHMS = 1;
				// if normal distribution
				if (buffer[0] == 1) {
					val1_BRAHMS = buffer[1];
					val2_BRAHMS = buffer[2];
					this->rngData_BRAHMS.seed = buffer[3];
					if (this->rngData_BRAHMS.seed == 0)
						this->rngData_BRAHMS.seed = getTime();
					buffer.resize(numEl_BRAHMS, 0);
					for (UINT32 i_BRAHMS = 0; i_BRAHMS < numEl_BRAHMS; ++i_BRAHMS) {
						buffer[i_BRAHMS] = (RNOR(&this->rngData_BRAHMS) * val2_BRAHMS) + val1_BRAHMS;
					}
				}
				// if uniform distribution
				if (buffer[0] == 2) {
					val1_BRAHMS = buffer[1];
					val2_BRAHMS = buffer[2];
					this->rngData_BRAHMS.seed = buffer[3];
					if (this->rngData_BRAHMS.seed == 0)
						this->rngData_BRAHMS.seed = getTime();
					buffer.resize(numEl_BRAHMS, 0);
					for (UINT32 i_BRAHMS = 0; i_BRAHMS < numEl_BRAHMS; ++i_BRAHMS) {
						buffer[i_BRAHMS] = (UNI(&this->rngData_BRAHMS) * (val2_BRAHMS-val1_BRAHMS)) + val1_BRAHMS;
					}
				}
			}

			if (nodeState.hasField("buffer") && !finishedThis) {
			buffer = nodeState.getField("buffer").getArrayDOUBLE();
				if (buffer.size() == 1) {
					buffer.resize(numEl_BRAHMS, buffer[0]);
				} else if (buffer.size() != numEl_BRAHMS) {
					berr << "State Variable buffer has incorrect dimensions (Its size is " << buffer.size() << ", not " << numEl_BRAHMS << ")";
				}
			}

			if (nodeState.hasField("bufferBIN_FILE_NAME") && !finishedThis) {
			        if (!nodeState.hasField("bufferBIN_NUM_ELEMENTS")) {
				        berr << "Found a binary file name without corresponding binary number of elements.";
				}
				buffer_BINARY_FILE_NAME = nodeState.getField("bufferBIN_FILE_NAME").getSTRING();
				int __temp_num_property_elements = nodeState.getField("bufferBIN_NUM_ELEMENTS").getINT32();

				// open the file for reading
				FILE * binfile;

				string fileName = modelDirectory_BRAHMS + "/" + buffer_BINARY_FILE_NAME;
				binfile = fopen(fileName.c_str(),"rb");
				if (!binfile) {
					berr << "Could not open properties list file: " << fileName;
				}

				buffer.resize(__temp_num_property_elements);
				vector<INT32> __temp_property_list_indices (__temp_num_property_elements, 0);
				vector<DOUBLE> __temp_property_list_values (__temp_num_property_elements, 0);
				for (int i_BRAHMS = 0; i_BRAHMS < __temp_num_property_elements; ++i_BRAHMS) {

					size_t ret_FOR_BRAHMS = fread(&__temp_property_list_indices[i_BRAHMS], sizeof(INT32), 1, binfile);
					if (ret_FOR_BRAHMS == -1) {berr << "Error loading binary properties: Failed to read an index";}
					ret_FOR_BRAHMS = fread(&__temp_property_list_values[i_BRAHMS], sizeof(DOUBLE), 1, binfile);
					if (ret_FOR_BRAHMS == -1) {berr << "Error loading binary properties: Failed to read a value";}
				}
				for (int i_BRAHMS = 0; i_BRAHMS < __temp_num_property_elements; ++i_BRAHMS) {
				        if ( __temp_property_list_indices[i_BRAHMS] > __temp_num_property_elements
					    || __temp_property_list_indices[i_BRAHMS] < 0) {
					    berr << "Error loading binary state variable property buffer: index "
						 << __temp_property_list_indices[i_BRAHMS] << " out of range";
					}
					buffer[__temp_property_list_indices[i_BRAHMS]] = __temp_property_list_values[i_BRAHMS];
				}
			}


			if (nodeState.hasField("bufferOVER1") && !finishedThis)
			{
				vector < double > __tempInputValues__;
				__tempInputValues__ = nodeState.getField("bufferOVER1").getArrayDOUBLE();
				// since OVER1 always means sparse Values
				if (buffer.size() == 1) {buffer.resize(numEl_BRAHMS, buffer[0]);
				}
				if (buffer.size() != numEl_BRAHMS) {berr << "State Variable buffer has a ValueList override but no base Values";}
				for (UINT32 i_BRAHMS = 0; i_BRAHMS < __tempInputValues__.size(); i_BRAHMS += 2) {
					if (__tempInputValues__[i_BRAHMS] > numEl_BRAHMS-1) {berr << "State Variable buffer has ValueList index " << float(i_BRAHMS)<< " (value of " << float(__tempInputValues__[i_BRAHMS]) << ") out of range";}
					buffer[__tempInputValues__[i_BRAHMS]] = __tempInputValues__[i_BRAHMS+1];
				}

			}

			if (nodeState.hasField("bufferOVER2") && !finishedThis)
			{
				vector < double > __tempInputValues__;
				__tempInputValues__ = nodeState.getField("bufferOVER2").getArrayDOUBLE();
				// OVER2 here means sparse Values
				if (buffer.size() != numEl_BRAHMS) {berr << "Experiment State Variable buffer has a ValueList override but no base Values";}
				for (UINT32 i_BRAHMS = 0; i_BRAHMS < __tempInputValues__.size(); i_BRAHMS += 2) {
					if (__tempInputValues__[i_BRAHMS] > numEl_BRAHMS-1) {berr << "Experiment State Variable buffer has ValueList index " << float(i_BRAHMS)<< " (value of " << float(__tempInputValues__[i_BRAHMS]) << ") out of range";}
					buffer[__tempInputValues__[i_BRAHMS]] = __tempInputValues__[i_BRAHMS+1];
				}

			}

			// output the values:
			/*bout << "buffer" << D_WARN;
			for (UINT32 i_BRAHMS = 0; i_BRAHMS < buffer.size(); ++i_BRAHMS) {
				bout << float(buffer[i_BRAHMS]) << D_WARN;
			}*/
			}


			// Parameters

			{
			bool finishedThis = false;
			if (nodeState.hasField("tau_ampaRANDXOVER2")) {
				this->allParamsDelaysAreFixedValue = false;
				this->tau_ampa = nodeState.getField("tau_ampaRANDXOVER2").getArrayDOUBLE();
				float val1_BRAHMS = 0;
				float val2_BRAHMS = 1;
				// if normal distribution
				if (this->tau_ampa[0] == 1) {
					val1_BRAHMS = this->tau_ampa[1];
					val2_BRAHMS = this->tau_ampa[2];
					this->rngData_BRAHMS.seed = tau_ampa[3];
					if (this->rngData_BRAHMS.seed == 0) {
						this->rngData_BRAHMS.seed = getTime();
					}
					this->tau_ampa.resize(numEl_BRAHMS, 0);
					for (UINT32 i_BRAHMS = 0; i_BRAHMS < numEl_BRAHMS; ++i_BRAHMS) {
						this->tau_ampa[i_BRAHMS] = (RNOR(&this->rngData_BRAHMS) * val2_BRAHMS) + val1_BRAHMS;
					}
				}
				// if uniform distribution
				if (this->tau_ampa[0] == 2) {
					val1_BRAHMS = this->tau_ampa[1];
					val2_BRAHMS = this->tau_ampa[2];
					this->rngData_BRAHMS.seed = this->tau_ampa[3];
					if (this->rngData_BRAHMS.seed == 0) {
						this->rngData_BRAHMS.seed = getTime();
					}
					this->tau_ampa.resize(numEl_BRAHMS, 0);
					for (UINT32 i_BRAHMS = 0; i_BRAHMS < numEl_BRAHMS; ++i_BRAHMS) {
						this->tau_ampa[i_BRAHMS] = (UNI(&this->rngData_BRAHMS) * (val2_BRAHMS-val1_BRAHMS)) + val1_BRAHMS;
					}
				}
				finishedThis = true;
			}
			if (nodeState.hasField("tau_ampaOVER2") && !finishedThis) {
				this->allParamsDelaysAreFixedValue = false;
				if (nodeState.getField("tau_ampaOVER2").getDims()[0] == 1) {
					this->tau_ampa = nodeState.getField("tau_ampaOVER2").getArrayDOUBLE();
					if (this->tau_ampa.size() == 1) {
						this->tau_ampa.resize(numEl_BRAHMS, tau_ampa[0]);
					} else if (this->tau_ampa.size() != numEl_BRAHMS) {
						berr << "Parameter tau_ampa has incorrect dimensions (Its size is " << this->tau_ampa.size() << ", not " << numEl_BRAHMS << ")";
					}
					finishedThis = true;
				}
			}

			if (nodeState.hasField("tau_ampaRANDX") && !finishedThis) {
				this->allParamsDelaysAreFixedValue = false;
				this->tau_ampa = nodeState.getField("tau_ampaRANDX").getArrayDOUBLE();
				float val1_BRAHMS = 0;
				float val2_BRAHMS = 1;
				// if normal distribution
				if (this->tau_ampa[0] == 1) {
					val1_BRAHMS = this->tau_ampa[1];
					val2_BRAHMS = this->tau_ampa[2];
					this->rngData_BRAHMS.seed = this->tau_ampa[3];
					if (this->rngData_BRAHMS.seed == 0) {
						this->rngData_BRAHMS.seed = getTime();
					}
					this->tau_ampa.resize(numEl_BRAHMS, 0);
					for (UINT32 i_BRAHMS = 0; i_BRAHMS < numEl_BRAHMS; ++i_BRAHMS) {
						this->tau_ampa[i_BRAHMS] = (RNOR(&this->rngData_BRAHMS) * val2_BRAHMS) + val1_BRAHMS;
					}
				}
				// if uniform distribution
				if (this->tau_ampa[0] == 2) {
					val1_BRAHMS = this->tau_ampa[1];
					val2_BRAHMS = this->tau_ampa[2];
					this->rngData_BRAHMS.seed = this->tau_ampa[3];
					if (this->rngData_BRAHMS.seed == 0) {
						this->rngData_BRAHMS.seed = getTime();
					}
					this->tau_ampa.resize(numEl_BRAHMS, 0);
					for (UINT32 i_BRAHMS = 0; i_BRAHMS < numEl_BRAHMS; ++i_BRAHMS) {
						this->tau_ampa[i_BRAHMS] = (UNI(&this->rngData_BRAHMS) * (val2_BRAHMS-val1_BRAHMS)) + val1_BRAHMS;
					}
				}
			}

			if (nodeState.hasField("tau_ampa") && !finishedThis)
			{
				this->tau_ampa = nodeState.getField("tau_ampa").getArrayDOUBLE();
				if (this->tau_ampa.size() == 1) {
					this->tau_ampa.resize(numEl_BRAHMS, tau_ampa[0]);
				} else if (this->tau_ampa.size() != numEl_BRAHMS) {
					berr << "Parameter tau_ampa has incorrect dimensions (Its size is " << tau_ampa.size() << ", not " << numEl_BRAHMS << ")";
				}
			}

			if (nodeState.hasField("tau_ampaBIN_FILE_NAME") && !finishedThis) {
				this->allParamsDelaysAreFixedValue = false;
			        if (!nodeState.hasField("tau_ampaBIN_NUM_ELEMENTS")) {
				        berr << "Found a binary file name without corresponding binary number of elements.";
				}
				string tau_ampa_BINARY_FILE_NAME = nodeState.getField("tau_ampaBIN_FILE_NAME").getSTRING();
				int __temp_num_property_elements = nodeState.getField("tau_ampaBIN_NUM_ELEMENTS").getINT32();

				// open the file for reading
				FILE * binfile;

				string fileName = modelDirectory_BRAHMS + "/" + tau_ampa_BINARY_FILE_NAME;
				binfile = fopen(fileName.c_str(),"rb");
				if (!binfile) {
					berr << "Could not open properties list file: " << fileName;
				}

				this->tau_ampa.resize(__temp_num_property_elements);
				vector<INT32> __temp_property_list_indices (__temp_num_property_elements, 0);
				vector<DOUBLE> __temp_property_list_values (__temp_num_property_elements, 0);
				for (int i_BRAHMS = 0; i_BRAHMS < __temp_num_property_elements; ++i_BRAHMS) {

					size_t ret_FOR_BRAHMS = fread(&__temp_property_list_indices[i_BRAHMS], sizeof(INT32), 1, binfile);
					if (ret_FOR_BRAHMS == -1) {berr << "Error loading binary properties: Failed to read an index";}
					ret_FOR_BRAHMS = fread(&__temp_property_list_values[i_BRAHMS], sizeof(DOUBLE), 1, binfile);
					if (ret_FOR_BRAHMS == -1) {berr << "Error loading binary properties: Failed to read a value";}
				}
				for (int i_BRAHMS = 0; i_BRAHMS < __temp_num_property_elements; ++i_BRAHMS) {
				        if ( __temp_property_list_indices[i_BRAHMS] > __temp_num_property_elements
					    || __temp_property_list_indices[i_BRAHMS] < 0) {
					    berr << "Error loading parameter binary property tau_ampa: index "
						 << __temp_property_list_indices[i_BRAHMS] << " out of range";
					}
					this->tau_ampa[__temp_property_list_indices[i_BRAHMS]] = __temp_property_list_values[i_BRAHMS];
				}
			}

			if (nodeState.hasField("tau_ampaOVER1") && !finishedThis) {
				this->allParamsDelaysAreFixedValue = false;
				vector < double > __tempInputValues__;
				__tempInputValues__ = nodeState.getField("tau_ampaOVER1").getArrayDOUBLE();
				// since OVER1 always means sparse Values
				if (this->tau_ampa.size() == 1) {
					this->tau_ampa.resize(numEl_BRAHMS, tau_ampa[0]);
				}
				if (this->tau_ampa.size() != numEl_BRAHMS) {
					berr << "Parameter tau_ampa has a ValueList override but no base Values";
				}
				for (UINT32 i_BRAHMS = 0; i_BRAHMS < __tempInputValues__.size(); i_BRAHMS += 2) {
					if (__tempInputValues__[i_BRAHMS] > numEl_BRAHMS-1) {
						berr << "Parameter tau_ampa has ValueList index " << float(i_BRAHMS)<< " (value of " << float(__tempInputValues__[i_BRAHMS]) << ") out of range";
					}
					this->tau_ampa[__tempInputValues__[i_BRAHMS]] = __tempInputValues__[i_BRAHMS+1];
				}
			}

			if (nodeState.hasField("tau_ampaOVER2") && !finishedThis) {
				this->allParamsDelaysAreFixedValue = false;
				vector < double > __tempInputValues__;
				__tempInputValues__ = nodeState.getField("tau_ampaOVER2").getArrayDOUBLE();
				// OVER2 here means sparse Values
				if (this->tau_ampa.size() != numEl_BRAHMS) {
					berr << "Experiment Parameter tau_ampa has a ValueList override but no base Values";
				}
				for (UINT32 i_BRAHMS = 0; i_BRAHMS < __tempInputValues__.size(); i_BRAHMS += 2) {
					if (__tempInputValues__[i_BRAHMS] > numEl_BRAHMS-1) {
						berr << "Experiment Parameter tau_ampa has ValueList index " << float(i_BRAHMS)<< " (value of " << float(__tempInputValues__[i_BRAHMS]) << ") out of range";
					}
					this->tau_ampa[__tempInputValues__[i_BRAHMS]] = __tempInputValues__[i_BRAHMS+1];
				}
			}
			// output the values:
			/*bout << "tau_ampa" << D_WARN;
			for (UINT32 i_BRAHMS = 0; i_BRAHMS < tau_ampa.size(); ++i_BRAHMS) {
				bout << float(tau_ampa[i_BRAHMS]) << D_WARN;
			}*/
			}

			{
			bool finishedThis = false;
			if (nodeState.hasField("E_ampaRANDXOVER2")) {
				this->allParamsDelaysAreFixedValue = false;
				this->E_ampa = nodeState.getField("E_ampaRANDXOVER2").getArrayDOUBLE();
				float val1_BRAHMS = 0;
				float val2_BRAHMS = 1;
				// if normal distribution
				if (this->E_ampa[0] == 1) {
					val1_BRAHMS = this->E_ampa[1];
					val2_BRAHMS = this->E_ampa[2];
					this->rngData_BRAHMS.seed = E_ampa[3];
					if (this->rngData_BRAHMS.seed == 0) {
						this->rngData_BRAHMS.seed = getTime();
					}
					this->E_ampa.resize(numEl_BRAHMS, 0);
					for (UINT32 i_BRAHMS = 0; i_BRAHMS < numEl_BRAHMS; ++i_BRAHMS) {
						this->E_ampa[i_BRAHMS] = (RNOR(&this->rngData_BRAHMS) * val2_BRAHMS) + val1_BRAHMS;
					}
				}
				// if uniform distribution
				if (this->E_ampa[0] == 2) {
					val1_BRAHMS = this->E_ampa[1];
					val2_BRAHMS = this->E_ampa[2];
					this->rngData_BRAHMS.seed = this->E_ampa[3];
					if (this->rngData_BRAHMS.seed == 0) {
						this->rngData_BRAHMS.seed = getTime();
					}
					this->E_ampa.resize(numEl_BRAHMS, 0);
					for (UINT32 i_BRAHMS = 0; i_BRAHMS < numEl_BRAHMS; ++i_BRAHMS) {
						this->E_ampa[i_BRAHMS] = (UNI(&this->rngData_BRAHMS) * (val2_BRAHMS-val1_BRAHMS)) + val1_BRAHMS;
					}
				}
				finishedThis = true;
			}
			if (nodeState.hasField("E_ampaOVER2") && !finishedThis) {
				this->allParamsDelaysAreFixedValue = false;
				if (nodeState.getField("E_ampaOVER2").getDims()[0] == 1) {
					this->E_ampa = nodeState.getField("E_ampaOVER2").getArrayDOUBLE();
					if (this->E_ampa.size() == 1) {
						this->E_ampa.resize(numEl_BRAHMS, E_ampa[0]);
					} else if (this->E_ampa.size() != numEl_BRAHMS) {
						berr << "Parameter E_ampa has incorrect dimensions (Its size is " << this->E_ampa.size() << ", not " << numEl_BRAHMS << ")";
					}
					finishedThis = true;
				}
			}

			if (nodeState.hasField("E_ampaRANDX") && !finishedThis) {
				this->allParamsDelaysAreFixedValue = false;
				this->E_ampa = nodeState.getField("E_ampaRANDX").getArrayDOUBLE();
				float val1_BRAHMS = 0;
				float val2_BRAHMS = 1;
				// if normal distribution
				if (this->E_ampa[0] == 1) {
					val1_BRAHMS = this->E_ampa[1];
					val2_BRAHMS = this->E_ampa[2];
					this->rngData_BRAHMS.seed = this->E_ampa[3];
					if (this->rngData_BRAHMS.seed == 0) {
						this->rngData_BRAHMS.seed = getTime();
					}
					this->E_ampa.resize(numEl_BRAHMS, 0);
					for (UINT32 i_BRAHMS = 0; i_BRAHMS < numEl_BRAHMS; ++i_BRAHMS) {
						this->E_ampa[i_BRAHMS] = (RNOR(&this->rngData_BRAHMS) * val2_BRAHMS) + val1_BRAHMS;
					}
				}
				// if uniform distribution
				if (this->E_ampa[0] == 2) {
					val1_BRAHMS = this->E_ampa[1];
					val2_BRAHMS = this->E_ampa[2];
					this->rngData_BRAHMS.seed = this->E_ampa[3];
					if (this->rngData_BRAHMS.seed == 0) {
						this->rngData_BRAHMS.seed = getTime();
					}
					this->E_ampa.resize(numEl_BRAHMS, 0);
					for (UINT32 i_BRAHMS = 0; i_BRAHMS < numEl_BRAHMS; ++i_BRAHMS) {
						this->E_ampa[i_BRAHMS] = (UNI(&this->rngData_BRAHMS) * (val2_BRAHMS-val1_BRAHMS)) + val1_BRAHMS;
					}
				}
			}

			if (nodeState.hasField("E_ampa") && !finishedThis)
			{
				this->E_ampa = nodeState.getField("E_ampa").getArrayDOUBLE();
				if (this->E_ampa.size() == 1) {
					this->E_ampa.resize(numEl_BRAHMS, E_ampa[0]);
				} else if (this->E_ampa.size() != numEl_BRAHMS) {
					berr << "Parameter E_ampa has incorrect dimensions (Its size is " << E_ampa.size() << ", not " << numEl_BRAHMS << ")";
				}
			}

			if (nodeState.hasField("E_ampaBIN_FILE_NAME") && !finishedThis) {
				this->allParamsDelaysAreFixedValue = false;
			        if (!nodeState.hasField("E_ampaBIN_NUM_ELEMENTS")) {
				        berr << "Found a binary file name without corresponding binary number of elements.";
				}
				string E_ampa_BINARY_FILE_NAME = nodeState.getField("E_ampaBIN_FILE_NAME").getSTRING();
				int __temp_num_property_elements = nodeState.getField("E_ampaBIN_NUM_ELEMENTS").getINT32();

				// open the file for reading
				FILE * binfile;

				string fileName = modelDirectory_BRAHMS + "/" + E_ampa_BINARY_FILE_NAME;
				binfile = fopen(fileName.c_str(),"rb");
				if (!binfile) {
					berr << "Could not open properties list file: " << fileName;
				}

				this->E_ampa.resize(__temp_num_property_elements);
				vector<INT32> __temp_property_list_indices (__temp_num_property_elements, 0);
				vector<DOUBLE> __temp_property_list_values (__temp_num_property_elements, 0);
				for (int i_BRAHMS = 0; i_BRAHMS < __temp_num_property_elements; ++i_BRAHMS) {

					size_t ret_FOR_BRAHMS = fread(&__temp_property_list_indices[i_BRAHMS], sizeof(INT32), 1, binfile);
					if (ret_FOR_BRAHMS == -1) {berr << "Error loading binary properties: Failed to read an index";}
					ret_FOR_BRAHMS = fread(&__temp_property_list_values[i_BRAHMS], sizeof(DOUBLE), 1, binfile);
					if (ret_FOR_BRAHMS == -1) {berr << "Error loading binary properties: Failed to read a value";}
				}
				for (int i_BRAHMS = 0; i_BRAHMS < __temp_num_property_elements; ++i_BRAHMS) {
				        if ( __temp_property_list_indices[i_BRAHMS] > __temp_num_property_elements
					    || __temp_property_list_indices[i_BRAHMS] < 0) {
					    berr << "Error loading parameter binary property E_ampa: index "
						 << __temp_property_list_indices[i_BRAHMS] << " out of range";
					}
					this->E_ampa[__temp_property_list_indices[i_BRAHMS]] = __temp_property_list_values[i_BRAHMS];
				}
			}

			if (nodeState.hasField("E_ampaOVER1") && !finishedThis) {
				this->allParamsDelaysAreFixedValue = false;
				vector < double > __tempInputValues__;
				__tempInputValues__ = nodeState.getField("E_ampaOVER1").getArrayDOUBLE();
				// since OVER1 always means sparse Values
				if (this->E_ampa.size() == 1) {
					this->E_ampa.resize(numEl_BRAHMS, E_ampa[0]);
				}
				if (this->E_ampa.size() != numEl_BRAHMS) {
					berr << "Parameter E_ampa has a ValueList override but no base Values";
				}
				for (UINT32 i_BRAHMS = 0; i_BRAHMS < __tempInputValues__.size(); i_BRAHMS += 2) {
					if (__tempInputValues__[i_BRAHMS] > numEl_BRAHMS-1) {
						berr << "Parameter E_ampa has ValueList index " << float(i_BRAHMS)<< " (value of " << float(__tempInputValues__[i_BRAHMS]) << ") out of range";
					}
					this->E_ampa[__tempInputValues__[i_BRAHMS]] = __tempInputValues__[i_BRAHMS+1];
				}
			}

			if (nodeState.hasField("E_ampaOVER2") && !finishedThis) {
				this->allParamsDelaysAreFixedValue = false;
				vector < double > __tempInputValues__;
				__tempInputValues__ = nodeState.getField("E_ampaOVER2").getArrayDOUBLE();
				// OVER2 here means sparse Values
				if (this->E_ampa.size() != numEl_BRAHMS) {
					berr << "Experiment Parameter E_ampa has a ValueList override but no base Values";
				}
				for (UINT32 i_BRAHMS = 0; i_BRAHMS < __tempInputValues__.size(); i_BRAHMS += 2) {
					if (__tempInputValues__[i_BRAHMS] > numEl_BRAHMS-1) {
						berr << "Experiment Parameter E_ampa has ValueList index " << float(i_BRAHMS)<< " (value of " << float(__tempInputValues__[i_BRAHMS]) << ") out of range";
					}
					this->E_ampa[__tempInputValues__[i_BRAHMS]] = __tempInputValues__[i_BRAHMS+1];
				}
			}
			// output the values:
			/*bout << "E_ampa" << D_WARN;
			for (UINT32 i_BRAHMS = 0; i_BRAHMS < E_ampa.size(); ++i_BRAHMS) {
				bout << float(E_ampa[i_BRAHMS]) << D_WARN;
			}*/
			}

			{
			bool finishedThis = false;
			if (nodeState.hasField("g_barRANDXOVER2")) {
				this->allParamsDelaysAreFixedValue = false;
				this->g_bar = nodeState.getField("g_barRANDXOVER2").getArrayDOUBLE();
				float val1_BRAHMS = 0;
				float val2_BRAHMS = 1;
				// if normal distribution
				if (this->g_bar[0] == 1) {
					val1_BRAHMS = this->g_bar[1];
					val2_BRAHMS = this->g_bar[2];
					this->rngData_BRAHMS.seed = g_bar[3];
					if (this->rngData_BRAHMS.seed == 0) {
						this->rngData_BRAHMS.seed = getTime();
					}
					this->g_bar.resize(numEl_BRAHMS, 0);
					for (UINT32 i_BRAHMS = 0; i_BRAHMS < numEl_BRAHMS; ++i_BRAHMS) {
						this->g_bar[i_BRAHMS] = (RNOR(&this->rngData_BRAHMS) * val2_BRAHMS) + val1_BRAHMS;
					}
				}
				// if uniform distribution
				if (this->g_bar[0] == 2) {
					val1_BRAHMS = this->g_bar[1];
					val2_BRAHMS = this->g_bar[2];
					this->rngData_BRAHMS.seed = this->g_bar[3];
					if (this->rngData_BRAHMS.seed == 0) {
						this->rngData_BRAHMS.seed = getTime();
					}
					this->g_bar.resize(numEl_BRAHMS, 0);
					for (UINT32 i_BRAHMS = 0; i_BRAHMS < numEl_BRAHMS; ++i_BRAHMS) {
						this->g_bar[i_BRAHMS] = (UNI(&this->rngData_BRAHMS) * (val2_BRAHMS-val1_BRAHMS)) + val1_BRAHMS;
					}
				}
				finishedThis = true;
			}
			if (nodeState.hasField("g_barOVER2") && !finishedThis) {
				this->allParamsDelaysAreFixedValue = false;
				if (nodeState.getField("g_barOVER2").getDims()[0] == 1) {
					this->g_bar = nodeState.getField("g_barOVER2").getArrayDOUBLE();
					if (this->g_bar.size() == 1) {
						this->g_bar.resize(numEl_BRAHMS, g_bar[0]);
					} else if (this->g_bar.size() != numEl_BRAHMS) {
						berr << "Parameter g_bar has incorrect dimensions (Its size is " << this->g_bar.size() << ", not " << numEl_BRAHMS << ")";
					}
					finishedThis = true;
				}
			}

			if (nodeState.hasField("g_barRANDX") && !finishedThis) {
				this->allParamsDelaysAreFixedValue = false;
				this->g_bar = nodeState.getField("g_barRANDX").getArrayDOUBLE();
				float val1_BRAHMS = 0;
				float val2_BRAHMS = 1;
				// if normal distribution
				if (this->g_bar[0] == 1) {
					val1_BRAHMS = this->g_bar[1];
					val2_BRAHMS = this->g_bar[2];
					this->rngData_BRAHMS.seed = this->g_bar[3];
					if (this->rngData_BRAHMS.seed == 0) {
						this->rngData_BRAHMS.seed = getTime();
					}
					this->g_bar.resize(numEl_BRAHMS, 0);
					for (UINT32 i_BRAHMS = 0; i_BRAHMS < numEl_BRAHMS; ++i_BRAHMS) {
						this->g_bar[i_BRAHMS] = (RNOR(&this->rngData_BRAHMS) * val2_BRAHMS) + val1_BRAHMS;
					}
				}
				// if uniform distribution
				if (this->g_bar[0] == 2) {
					val1_BRAHMS = this->g_bar[1];
					val2_BRAHMS = this->g_bar[2];
					this->rngData_BRAHMS.seed = this->g_bar[3];
					if (this->rngData_BRAHMS.seed == 0) {
						this->rngData_BRAHMS.seed = getTime();
					}
					this->g_bar.resize(numEl_BRAHMS, 0);
					for (UINT32 i_BRAHMS = 0; i_BRAHMS < numEl_BRAHMS; ++i_BRAHMS) {
						this->g_bar[i_BRAHMS] = (UNI(&this->rngData_BRAHMS) * (val2_BRAHMS-val1_BRAHMS)) + val1_BRAHMS;
					}
				}
			}

			if (nodeState.hasField("g_bar") && !finishedThis)
			{
				this->g_bar = nodeState.getField("g_bar").getArrayDOUBLE();
				if (this->g_bar.size() == 1) {
					this->g_bar.resize(numEl_BRAHMS, g_bar[0]);
				} else if (this->g_bar.size() != numEl_BRAHMS) {
					berr << "Parameter g_bar has incorrect dimensions (Its size is " << g_bar.size() << ", not " << numEl_BRAHMS << ")";
				}
			}

			if (nodeState.hasField("g_barBIN_FILE_NAME") && !finishedThis) {
				this->allParamsDelaysAreFixedValue = false;
			        if (!nodeState.hasField("g_barBIN_NUM_ELEMENTS")) {
				        berr << "Found a binary file name without corresponding binary number of elements.";
				}
				string g_bar_BINARY_FILE_NAME = nodeState.getField("g_barBIN_FILE_NAME").getSTRING();
				int __temp_num_property_elements = nodeState.getField("g_barBIN_NUM_ELEMENTS").getINT32();

				// open the file for reading
				FILE * binfile;

				string fileName = modelDirectory_BRAHMS + "/" + g_bar_BINARY_FILE_NAME;
				binfile = fopen(fileName.c_str(),"rb");
				if (!binfile) {
					berr << "Could not open properties list file: " << fileName;
				}

				this->g_bar.resize(__temp_num_property_elements);
				vector<INT32> __temp_property_list_indices (__temp_num_property_elements, 0);
				vector<DOUBLE> __temp_property_list_values (__temp_num_property_elements, 0);
				for (int i_BRAHMS = 0; i_BRAHMS < __temp_num_property_elements; ++i_BRAHMS) {

					size_t ret_FOR_BRAHMS = fread(&__temp_property_list_indices[i_BRAHMS], sizeof(INT32), 1, binfile);
					if (ret_FOR_BRAHMS == -1) {berr << "Error loading binary properties: Failed to read an index";}
					ret_FOR_BRAHMS = fread(&__temp_property_list_values[i_BRAHMS], sizeof(DOUBLE), 1, binfile);
					if (ret_FOR_BRAHMS == -1) {berr << "Error loading binary properties: Failed to read a value";}
				}
				for (int i_BRAHMS = 0; i_BRAHMS < __temp_num_property_elements; ++i_BRAHMS) {
				        if ( __temp_property_list_indices[i_BRAHMS] > __temp_num_property_elements
					    || __temp_property_list_indices[i_BRAHMS] < 0) {
					    berr << "Error loading parameter binary property g_bar: index "
						 << __temp_property_list_indices[i_BRAHMS] << " out of range";
					}
					this->g_bar[__temp_property_list_indices[i_BRAHMS]] = __temp_property_list_values[i_BRAHMS];
				}
			}

			if (nodeState.hasField("g_barOVER1") && !finishedThis) {
				this->allParamsDelaysAreFixedValue = false;
				vector < double > __tempInputValues__;
				__tempInputValues__ = nodeState.getField("g_barOVER1").getArrayDOUBLE();
				// since OVER1 always means sparse Values
				if (this->g_bar.size() == 1) {
					this->g_bar.resize(numEl_BRAHMS, g_bar[0]);
				}
				if (this->g_bar.size() != numEl_BRAHMS) {
					berr << "Parameter g_bar has a ValueList override but no base Values";
				}
				for (UINT32 i_BRAHMS = 0; i_BRAHMS < __tempInputValues__.size(); i_BRAHMS += 2) {
					if (__tempInputValues__[i_BRAHMS] > numEl_BRAHMS-1) {
						berr << "Parameter g_bar has ValueList index " << float(i_BRAHMS)<< " (value of " << float(__tempInputValues__[i_BRAHMS]) << ") out of range";
					}
					this->g_bar[__tempInputValues__[i_BRAHMS]] = __tempInputValues__[i_BRAHMS+1];
				}
			}

			if (nodeState.hasField("g_barOVER2") && !finishedThis) {
				this->allParamsDelaysAreFixedValue = false;
				vector < double > __tempInputValues__;
				__tempInputValues__ = nodeState.getField("g_barOVER2").getArrayDOUBLE();
				// OVER2 here means sparse Values
				if (this->g_bar.size() != numEl_BRAHMS) {
					berr << "Experiment Parameter g_bar has a ValueList override but no base Values";
				}
				for (UINT32 i_BRAHMS = 0; i_BRAHMS < __tempInputValues__.size(); i_BRAHMS += 2) {
					if (__tempInputValues__[i_BRAHMS] > numEl_BRAHMS-1) {
						berr << "Experiment Parameter g_bar has ValueList index " << float(i_BRAHMS)<< " (value of " << float(__tempInputValues__[i_BRAHMS]) << ") out of range";
					}
					this->g_bar[__tempInputValues__[i_BRAHMS]] = __tempInputValues__[i_BRAHMS+1];
				}
			}
			// output the values:
			/*bout << "g_bar" << D_WARN;
			for (UINT32 i_BRAHMS = 0; i_BRAHMS < g_bar.size(); ++i_BRAHMS) {
				bout << float(g_bar[i_BRAHMS]) << D_WARN;
			}*/
			}

			{
			bool finishedThis = false;
			if (nodeState.hasField("buffer_maxRANDXOVER2")) {
				this->allParamsDelaysAreFixedValue = false;
				this->buffer_max = nodeState.getField("buffer_maxRANDXOVER2").getArrayDOUBLE();
				float val1_BRAHMS = 0;
				float val2_BRAHMS = 1;
				// if normal distribution
				if (this->buffer_max[0] == 1) {
					val1_BRAHMS = this->buffer_max[1];
					val2_BRAHMS = this->buffer_max[2];
					this->rngData_BRAHMS.seed = buffer_max[3];
					if (this->rngData_BRAHMS.seed == 0) {
						this->rngData_BRAHMS.seed = getTime();
					}
					this->buffer_max.resize(numEl_BRAHMS, 0);
					for (UINT32 i_BRAHMS = 0; i_BRAHMS < numEl_BRAHMS; ++i_BRAHMS) {
						this->buffer_max[i_BRAHMS] = (RNOR(&this->rngData_BRAHMS) * val2_BRAHMS) + val1_BRAHMS;
					}
				}
				// if uniform distribution
				if (this->buffer_max[0] == 2) {
					val1_BRAHMS = this->buffer_max[1];
					val2_BRAHMS = this->buffer_max[2];
					this->rngData_BRAHMS.seed = this->buffer_max[3];
					if (this->rngData_BRAHMS.seed == 0) {
						this->rngData_BRAHMS.seed = getTime();
					}
					this->buffer_max.resize(numEl_BRAHMS, 0);
					for (UINT32 i_BRAHMS = 0; i_BRAHMS < numEl_BRAHMS; ++i_BRAHMS) {
						this->buffer_max[i_BRAHMS] = (UNI(&this->rngData_BRAHMS) * (val2_BRAHMS-val1_BRAHMS)) + val1_BRAHMS;
					}
				}
				finishedThis = true;
			}
			if (nodeState.hasField("buffer_maxOVER2") && !finishedThis) {
				this->allParamsDelaysAreFixedValue = false;
				if (nodeState.getField("buffer_maxOVER2").getDims()[0] == 1) {
					this->buffer_max = nodeState.getField("buffer_maxOVER2").getArrayDOUBLE();
					if (this->buffer_max.size() == 1) {
						this->buffer_max.resize(numEl_BRAHMS, buffer_max[0]);
					} else if (this->buffer_max.size() != numEl_BRAHMS) {
						berr << "Parameter buffer_max has incorrect dimensions (Its size is " << this->buffer_max.size() << ", not " << numEl_BRAHMS << ")";
					}
					finishedThis = true;
				}
			}

			if (nodeState.hasField("buffer_maxRANDX") && !finishedThis) {
				this->allParamsDelaysAreFixedValue = false;
				this->buffer_max = nodeState.getField("buffer_maxRANDX").getArrayDOUBLE();
				float val1_BRAHMS = 0;
				float val2_BRAHMS = 1;
				// if normal distribution
				if (this->buffer_max[0] == 1) {
					val1_BRAHMS = this->buffer_max[1];
					val2_BRAHMS = this->buffer_max[2];
					this->rngData_BRAHMS.seed = this->buffer_max[3];
					if (this->rngData_BRAHMS.seed == 0) {
						this->rngData_BRAHMS.seed = getTime();
					}
					this->buffer_max.resize(numEl_BRAHMS, 0);
					for (UINT32 i_BRAHMS = 0; i_BRAHMS < numEl_BRAHMS; ++i_BRAHMS) {
						this->buffer_max[i_BRAHMS] = (RNOR(&this->rngData_BRAHMS) * val2_BRAHMS) + val1_BRAHMS;
					}
				}
				// if uniform distribution
				if (this->buffer_max[0] == 2) {
					val1_BRAHMS = this->buffer_max[1];
					val2_BRAHMS = this->buffer_max[2];
					this->rngData_BRAHMS.seed = this->buffer_max[3];
					if (this->rngData_BRAHMS.seed == 0) {
						this->rngData_BRAHMS.seed = getTime();
					}
					this->buffer_max.resize(numEl_BRAHMS, 0);
					for (UINT32 i_BRAHMS = 0; i_BRAHMS < numEl_BRAHMS; ++i_BRAHMS) {
						this->buffer_max[i_BRAHMS] = (UNI(&this->rngData_BRAHMS) * (val2_BRAHMS-val1_BRAHMS)) + val1_BRAHMS;
					}
				}
			}

			if (nodeState.hasField("buffer_max") && !finishedThis)
			{
				this->buffer_max = nodeState.getField("buffer_max").getArrayDOUBLE();
				if (this->buffer_max.size() == 1) {
					this->buffer_max.resize(numEl_BRAHMS, buffer_max[0]);
				} else if (this->buffer_max.size() != numEl_BRAHMS) {
					berr << "Parameter buffer_max has incorrect dimensions (Its size is " << buffer_max.size() << ", not " << numEl_BRAHMS << ")";
				}
			}

			if (nodeState.hasField("buffer_maxBIN_FILE_NAME") && !finishedThis) {
				this->allParamsDelaysAreFixedValue = false;
			        if (!nodeState.hasField("buffer_maxBIN_NUM_ELEMENTS")) {
				        berr << "Found a binary file name without corresponding binary number of elements.";
				}
				string buffer_max_BINARY_FILE_NAME = nodeState.getField("buffer_maxBIN_FILE_NAME").getSTRING();
				int __temp_num_property_elements = nodeState.getField("buffer_maxBIN_NUM_ELEMENTS").getINT32();

				// open the file for reading
				FILE * binfile;

				string fileName = modelDirectory_BRAHMS + "/" + buffer_max_BINARY_FILE_NAME;
				binfile = fopen(fileName.c_str(),"rb");
				if (!binfile) {
					berr << "Could not open properties list file: " << fileName;
				}

				this->buffer_max.resize(__temp_num_property_elements);
				vector<INT32> __temp_property_list_indices (__temp_num_property_elements, 0);
				vector<DOUBLE> __temp_property_list_values (__temp_num_property_elements, 0);
				for (int i_BRAHMS = 0; i_BRAHMS < __temp_num_property_elements; ++i_BRAHMS) {

					size_t ret_FOR_BRAHMS = fread(&__temp_property_list_indices[i_BRAHMS], sizeof(INT32), 1, binfile);
					if (ret_FOR_BRAHMS == -1) {berr << "Error loading binary properties: Failed to read an index";}
					ret_FOR_BRAHMS = fread(&__temp_property_list_values[i_BRAHMS], sizeof(DOUBLE), 1, binfile);
					if (ret_FOR_BRAHMS == -1) {berr << "Error loading binary properties: Failed to read a value";}
				}
				for (int i_BRAHMS = 0; i_BRAHMS < __temp_num_property_elements; ++i_BRAHMS) {
				        if ( __temp_property_list_indices[i_BRAHMS] > __temp_num_property_elements
					    || __temp_property_list_indices[i_BRAHMS] < 0) {
					    berr << "Error loading parameter binary property buffer_max: index "
						 << __temp_property_list_indices[i_BRAHMS] << " out of range";
					}
					this->buffer_max[__temp_property_list_indices[i_BRAHMS]] = __temp_property_list_values[i_BRAHMS];
				}
			}

			if (nodeState.hasField("buffer_maxOVER1") && !finishedThis) {
				this->allParamsDelaysAreFixedValue = false;
				vector < double > __tempInputValues__;
				__tempInputValues__ = nodeState.getField("buffer_maxOVER1").getArrayDOUBLE();
				// since OVER1 always means sparse Values
				if (this->buffer_max.size() == 1) {
					this->buffer_max.resize(numEl_BRAHMS, buffer_max[0]);
				}
				if (this->buffer_max.size() != numEl_BRAHMS) {
					berr << "Parameter buffer_max has a ValueList override but no base Values";
				}
				for (UINT32 i_BRAHMS = 0; i_BRAHMS < __tempInputValues__.size(); i_BRAHMS += 2) {
					if (__tempInputValues__[i_BRAHMS] > numEl_BRAHMS-1) {
						berr << "Parameter buffer_max has ValueList index " << float(i_BRAHMS)<< " (value of " << float(__tempInputValues__[i_BRAHMS]) << ") out of range";
					}
					this->buffer_max[__tempInputValues__[i_BRAHMS]] = __tempInputValues__[i_BRAHMS+1];
				}
			}

			if (nodeState.hasField("buffer_maxOVER2") && !finishedThis) {
				this->allParamsDelaysAreFixedValue = false;
				vector < double > __tempInputValues__;
				__tempInputValues__ = nodeState.getField("buffer_maxOVER2").getArrayDOUBLE();
				// OVER2 here means sparse Values
				if (this->buffer_max.size() != numEl_BRAHMS) {
					berr << "Experiment Parameter buffer_max has a ValueList override but no base Values";
				}
				for (UINT32 i_BRAHMS = 0; i_BRAHMS < __tempInputValues__.size(); i_BRAHMS += 2) {
					if (__tempInputValues__[i_BRAHMS] > numEl_BRAHMS-1) {
						berr << "Experiment Parameter buffer_max has ValueList index " << float(i_BRAHMS)<< " (value of " << float(__tempInputValues__[i_BRAHMS]) << ") out of range";
					}
					this->buffer_max[__tempInputValues__[i_BRAHMS]] = __tempInputValues__[i_BRAHMS+1];
				}
			}
			// output the values:
			/*bout << "buffer_max" << D_WARN;
			for (UINT32 i_BRAHMS = 0; i_BRAHMS < buffer_max.size(); ++i_BRAHMS) {
				bout << float(buffer_max[i_BRAHMS]) << D_WARN;
			}*/
			}


			// Alias resize
I_ampa.resize(numEl_BRAHMS, 0);


			// Log base name
			baseNameForLogs_BRAHMS = "../log/" + nodeState.getField("logfileNameForComponent").getSTRING();
			g_ampa_BINARY_FILE_NAME_OUT = "../model/" + nodeState.getField("g_ampaBIN_FILE_NAME").getSTRING();
			buffer_BINARY_FILE_NAME_OUT = "../model/" + nodeState.getField("bufferBIN_FILE_NAME").getSTRING();


			// Logs

			// check for existence of log stateNode
			if (nodeState.hasField("I_ampaLOG")) {
				// we have a log! Read the data in:
				// check we got some data first
				VDOUBLE tempLogData_BRAHMS = nodeState.getField("I_ampaLOG").getArrayDOUBLE();
				if (tempLogData_BRAHMS.size() == 0) berr << "ERROR: log with no indices";
				// if we are logging 'all'
				if (tempLogData_BRAHMS[0] < -0.1) {
					I_ampaLOGMAP.push_back(-2);
				} else {
				// otherwise
					// resize the logvar:
					I_ampaLOGVAR.resize(tempLogData_BRAHMS.size(),0);
					// resize the logmap:
					I_ampaLOGMAP.resize(numEl_BRAHMS,-1);
					// set the logmap values - checking for out of range values
					for (unsigned int i_BRAHMS = 0; i_BRAHMS < tempLogData_BRAHMS.size(); ++i_BRAHMS) {
						if (tempLogData_BRAHMS[i_BRAHMS]+0.5 > numEl_BRAHMS) {
							bout << "Attempting to log an index out of range" << D_WARN;
						} else {
							// set in mapping that the i_BRAHMSth log value relates to the tempLogData_BRAHMS[i_BRAHMS]th neuron
							I_ampaLOGMAP[(int) tempLogData_BRAHMS[i_BRAHMS]] = i_BRAHMS;
						}
					}
				}
				// open the logfile for writing
				string logFileName_BRAHMS = baseNameForLogs_BRAHMS;
				logFileName_BRAHMS.append("_I_ampa_log.bin");
				I_ampaLOGFILE = fopen(logFileName_BRAHMS.c_str(),"wb");
			}

			// check for existence of log stateNode
			if (nodeState.hasField("g_ampaLOG")) {
				// we have a log! Read the data in:
				// check we got some data first
				VDOUBLE tempLogData_BRAHMS = nodeState.getField("g_ampaLOG").getArrayDOUBLE();
				if (tempLogData_BRAHMS.size() == 0) berr << "ERROR: log with no indices";
				// if we are logging 'all'
				if (tempLogData_BRAHMS[0] < -0.1) {
					g_ampaLOGMAP.push_back(-2);
				} else {
				// otherwise
					// resize the logvar:
					g_ampaLOGVAR.resize(tempLogData_BRAHMS.size(),0);
					// resize the logmap:
					g_ampaLOGMAP.resize(numEl_BRAHMS,-1);
					// set the logmap values - checking for out of range values
					for (unsigned int i_BRAHMS = 0; i_BRAHMS < tempLogData_BRAHMS.size(); ++i_BRAHMS) {
						if (tempLogData_BRAHMS[i_BRAHMS]+0.5 > numEl_BRAHMS) {
							bout << "Attempting to log an index out of range" << D_WARN;
						} else {
							// set in mapping that the i_BRAHMSth log value relates to the tempLogData_BRAHMS[i_BRAHMS]th neuron
							g_ampaLOGMAP[(int) tempLogData_BRAHMS[i_BRAHMS]] = i_BRAHMS;
						}
					}
				}
				// open the logfile for writing
				string logFileName_BRAHMS = baseNameForLogs_BRAHMS;
				logFileName_BRAHMS.append("_g_ampa_log.bin");
				g_ampaLOGFILE = fopen(logFileName_BRAHMS.c_str(),"wb");
			}

            AMPAbufO__Oregime.resize(numEl_BRAHMS,1);
            AMPAbufO__OregimeNext.resize(numEl_BRAHMS,0);

			dt = 1000.0f * time->sampleRate.den / time->sampleRate.num;


(CurrentP__Pg_ampa) = &COMPONENT_CLASS_CPP::CurrentV__Vg_ampa;
		S.resize(numEl_BRAHMS,0);


		}

		// CREATE THE PORTS
		case EVENT_INIT_CONNECT:
		{
			Dims sizeDims_BRAHMS;
			for (int i_BRAHMS = 0; i_BRAHMS < size_BRAHMS.size(); ++i_BRAHMS) {
				sizeDims_BRAHMS.push_back(size_BRAHMS[i_BRAHMS]);
			}
			//	on first call
			if (event->flags & F_FIRST_CALL)
			{


				PORTI_ampa.setName("I_ampa");
				PORTI_ampa.create(hComponent);
				PORTI_ampa.setStructure(TYPE_REAL | TYPE_DOUBLE, Dims(numElements_BRAHMS).cdims());

				PORTg_ampa.setName("g_ampa");
				PORTg_ampa.create(hComponent);
				PORTg_ampa.setStructure(TYPE_REAL | TYPE_DOUBLE, Dims(numElements_BRAHMS).cdims());


			}

			//	on last call
			if (event->flags & F_LAST_CALL)
			{

				int numInputs_BRAHMS;
				Symbol set_BRAHMS;

				// create input ports

				set_BRAHMS = iif.getSet("v");
				numInputs_BRAHMS = iif.getNumberOfPorts(set_BRAHMS);
				PORTv.resize(numInputs_BRAHMS);
				v.resize(numElements_BRAHMS,0);
				for (int i_BRAHMS = 0; i_BRAHMS < numInputs_BRAHMS; ++i_BRAHMS) {
					PORTv[i_BRAHMS].selectSet(set_BRAHMS);
					PORTv[i_BRAHMS].attach(hComponent, i_BRAHMS);
					PORTv[i_BRAHMS].validateStructure(TYPE_REAL | TYPE_DOUBLE, Dims(numElements_BRAHMS).cdims());
				}


				set_BRAHMS = iif.getSet("S");
				numInputs_BRAHMS = iif.getNumberOfPorts(set_BRAHMS);
				PORTS.resize(numInputs_BRAHMS);
				for (int i_BRAHMS_LOOP = 0; i_BRAHMS_LOOP < numInputs_BRAHMS; ++i_BRAHMS_LOOP) {
					PORTS[i_BRAHMS_LOOP].selectSet(set_BRAHMS);
					PORTS[i_BRAHMS_LOOP].attach(hComponent, i_BRAHMS_LOOP);

				}




			}

			// re-seed
			this->rngData_BRAHMS.seed = getTime();

			//	ok
			return C_OK;
		}

		case EVENT_RUN_SERVICE:
		{

			t = float(time->now)*dt;

			int num_BRAHMS;
			int numEl_BRAHMS = numElements_BRAHMS;

            for (int i_BRAHMS = 0; i_BRAHMS < AMPAbufO__Oregime.size(); ++i_BRAHMS) {

                AMPAbufO__OregimeNext[i_BRAHMS] = AMPAbufO__Oregime[i_BRAHMS];

			}

			// service inputs


		DOUBLE* DATAv;
			for (int i_BRAHMS = 0; i_BRAHMS < PORTv.size(); ++i_BRAHMS) {
				DATAv = (DOUBLE*) PORTv[i_BRAHMS].getContent();
				for (int j_BRAHMS = 0; j_BRAHMS < v.size(); ++j_BRAHMS) {
					// reset value then sum inputs
					if (i_BRAHMS == 0) v[j_BRAHMS] = 0;
					v[j_BRAHMS] += DATAv[j_BRAHMS];
				}
			}

			vector < INT32* > DATAS;
			vector < UINT32 > COUNTS;
			DATAS.resize(PORTS.size());
			COUNTS.resize(PORTS.size());
			for (int i_BRAHMS = 0; i_BRAHMS < PORTS.size(); ++i_BRAHMS) {
				COUNTS[i_BRAHMS] = PORTS[i_BRAHMS].getContent(DATAS[i_BRAHMS]);
			}

			//Dynamics events

			//Dynamics events

			for (int in_BRAHMS = 0; in_BRAHMS < DATAS.size(); ++in_BRAHMS) {
				for (int i_BRAHMS = 0; i_BRAHMS < COUNTS[in_BRAHMS]; i_BRAHMS+=3) {
				// extract impulse
				INT32 impulseIndex__In;
				DOUBLE impulseValue__In;
				getImpulse(DATAS[in_BRAHMS], i_BRAHMS, impulseIndex__In, impulseValue__In);
				num_BRAHMS = impulseIndex__In;
				// assign the impulse value
				S[num_BRAHMS] = impulseValue__In;

					switch (AMPAbufO__Oregime[num_BRAHMS]) {

						//Regime
						case AMPAbufX__XCurrent:

					//OnImpulse1
					AMPAbufO__OregimeNext[num_BRAHMS]=AMPAbufX__XCurrent;

     				//StateAssignment
					buffer[num_BRAHMS] = buffer[num_BRAHMS] + 1;

						break;

					}
				}
			}

			//Dynamics time derivatives
			for (num_BRAHMS = 0; num_BRAHMS < numEl_BRAHMS; ++num_BRAHMS) {

				// switch on regime:
				switch (AMPAbufO__Oregime[num_BRAHMS]) {

					//Regime
					case AMPAbufX__XCurrent:
					{

					//TimeDerivative
					float g_ampa_tempVALforINT = this->integrate(float(g_ampa[num_BRAHMS]), CurrentP__Pg_ampa , num_BRAHMS);

					//TimeDerivative finalisation
					g_ampa[num_BRAHMS] = g_ampa_tempVALforINT;

					}
					break;

				}
			}

                        // Could add a post-transition/pre-alias thing here?
			for (num_BRAHMS = 0; num_BRAHMS < numEl_BRAHMS; ++num_BRAHMS) {
                            if (buffer[num_BRAHMS] <= buffer_max[num_BRAHMS]) {
                                g_ampa[num_BRAHMS] = g_ampa[num_BRAHMS] + g_bar[num_BRAHMS]*buffer[num_BRAHMS];
                                buffer[num_BRAHMS] = 0;
                            } else {
                                g_ampa[num_BRAHMS] = g_ampa[num_BRAHMS] + g_bar[num_BRAHMS]*buffer_max[num_BRAHMS];
                                buffer[num_BRAHMS] = buffer[num_BRAHMS] - buffer_max[num_BRAHMS];
                            }
                        }

			for (num_BRAHMS = 0; num_BRAHMS < numEl_BRAHMS; ++num_BRAHMS) {

					//Alias assignment for ports
					I_ampa[num_BRAHMS]=g_ampa[num_BRAHMS]*(E_ampa[num_BRAHMS]-v[num_BRAHMS]);

			}


			// Apply regime changes
            for (int i_BRAHMS = 0; i_BRAHMS < AMPAbufO__Oregime.size(); ++i_BRAHMS) {
                AMPAbufO__Oregime[i_BRAHMS] = AMPAbufO__OregimeNext[i_BRAHMS];

                // updating logs...

				if (I_ampaLOGMAP.size() > 0) {
					if (I_ampaLOGMAP[0] > -1.1) {
						if (I_ampaLOGMAP[i_BRAHMS]+1)
							I_ampaLOGVAR[I_ampaLOGMAP[i_BRAHMS]] = I_ampa[i_BRAHMS];
					}
				}

				if (g_ampaLOGMAP.size() > 0) {
					if (g_ampaLOGMAP[0] > -1.1) {
						if (g_ampaLOGMAP[i_BRAHMS]+1)
							g_ampaLOGVAR[g_ampaLOGMAP[i_BRAHMS]] = g_ampa[i_BRAHMS];
					}
				}


			}

			// updating logs...


			// writing logs...

				if (I_ampaLOGMAP.size() > 0) {
					if (I_ampaLOGMAP[0] < -1.1) {
						// write data
						size_t written_BRAHMS = fwrite(&I_ampa[0],sizeof(double),I_ampa.size(),I_ampaLOGFILE);
						if (written_BRAHMS != I_ampa.size()) berr << "Error writing logfile for " << baseNameForLogs_BRAHMS << "_I_ampa";
					} else {
						// write data
						size_t written_BRAHMS = fwrite(&I_ampaLOGVAR[0],sizeof(double),I_ampaLOGVAR.size(),I_ampaLOGFILE);
						if (written_BRAHMS != I_ampaLOGVAR.size()) berr << "Error writing logfile for " << baseNameForLogs_BRAHMS << "_I_ampa";
					}
				}

				if (g_ampaLOGMAP.size() > 0) {
					if (g_ampaLOGMAP[0] < -1.1) {
						// write data
						size_t written_BRAHMS = fwrite(&g_ampa[0],sizeof(double),g_ampa.size(),g_ampaLOGFILE);
						if (written_BRAHMS != g_ampa.size()) berr << "Error writing logfile for " << baseNameForLogs_BRAHMS << "_g_ampa";
					} else {
						// write data
						size_t written_BRAHMS = fwrite(&g_ampaLOGVAR[0],sizeof(double),g_ampaLOGVAR.size(),g_ampaLOGFILE);
						if (written_BRAHMS != g_ampaLOGVAR.size()) berr << "Error writing logfile for " << baseNameForLogs_BRAHMS << "_g_ampa";
					}
				}

			PORTI_ampa.setContent(&I_ampa[0]);

			PORTg_ampa.setContent(&g_ampa[0]);



			//	ok
			return C_OK;
		}

		case EVENT_RUN_STOP:
		{
			int numEl_BRAHMS = numElements_BRAHMS;
			t = float(time->now)*dt;


			if (I_ampaLOGMAP.size() > 0) {

				FILE * I_ampaLOGREPORT;
				string logFileName_BRAHMS = baseNameForLogs_BRAHMS;
				logFileName_BRAHMS.append("_I_ampa_logrep.xml");
				I_ampaLOGREPORT = fopen(logFileName_BRAHMS.c_str(),"w");
				logFileName_BRAHMS = baseNameForLogs_BRAHMS;
				logFileName_BRAHMS.append("_I_ampa_log.bin");
  			unsigned found = logFileName_BRAHMS.find_last_of("/\\");
  			logFileName_BRAHMS = logFileName_BRAHMS.substr(found+1);
				fprintf(I_ampaLOGREPORT, "<LogReport>\n");
				fprintf(I_ampaLOGREPORT, "	<AnalogLog>\n");
				fprintf(I_ampaLOGREPORT, "		<LogFile>%s</LogFile>\n",logFileName_BRAHMS.c_str());
				fprintf(I_ampaLOGREPORT, "		<LogFileType>binary</LogFileType>\n");
				fprintf(I_ampaLOGREPORT, "		<LogEndTime>%f</LogEndTime>\n",t);
				if (I_ampaLOGMAP[0] > -1.1) {
					for (unsigned int i = 0; i < I_ampaLOGMAP.size(); ++i) {
						if (I_ampaLOGMAP[i] > -0.1) {
							fprintf(I_ampaLOGREPORT, "		<LogCol index=\"%d\" heading=\"I_ampa\" dims=\"\" type=\"double\"/>\n",i);
						}
					}
				} else {
					fprintf(I_ampaLOGREPORT, "		<LogAll size=\"%d\" headings=\"I_ampa\" type=\"double\" dims=\"\"/>\n",numEl_BRAHMS);
				}
				fprintf(I_ampaLOGREPORT,"		<TimeStep dt=\"%f\"/>\n", dt);
				fprintf(I_ampaLOGREPORT, "	</AnalogLog>\n");
				fprintf(I_ampaLOGREPORT, "</LogReport>\n");

				fclose(I_ampaLOGREPORT);
				fclose(I_ampaLOGFILE);
			}

			if (g_ampaLOGMAP.size() > 0) {

				FILE * g_ampaLOGREPORT;
				string logFileName_BRAHMS = baseNameForLogs_BRAHMS;
				logFileName_BRAHMS.append("_g_ampa_logrep.xml");
				g_ampaLOGREPORT = fopen(logFileName_BRAHMS.c_str(),"w");
				logFileName_BRAHMS = baseNameForLogs_BRAHMS;
				logFileName_BRAHMS.append("_g_ampa_log.bin");
  			unsigned found = logFileName_BRAHMS.find_last_of("/\\");
  			logFileName_BRAHMS = logFileName_BRAHMS.substr(found+1);
				fprintf(g_ampaLOGREPORT, "<LogReport>\n");
				fprintf(g_ampaLOGREPORT, "	<AnalogLog>\n");
				fprintf(g_ampaLOGREPORT, "		<LogFile>%s</LogFile>\n",logFileName_BRAHMS.c_str());
				fprintf(g_ampaLOGREPORT, "		<LogFileType>binary</LogFileType>\n");
				fprintf(g_ampaLOGREPORT, "		<LogEndTime>%f</LogEndTime>\n",t);
				if (g_ampaLOGMAP[0] > -1.1) {
					for (unsigned int i = 0; i < g_ampaLOGMAP.size(); ++i) {
						if (g_ampaLOGMAP[i] > -0.1) {
							fprintf(g_ampaLOGREPORT, "		<LogCol index=\"%d\" heading=\"g_ampa\" dims=\"\" type=\"double\"/>\n",i);
						}
					}
				} else {
					fprintf(g_ampaLOGREPORT, "		<LogAll size=\"%d\" headings=\"g_ampa\" type=\"double\" dims=\"\"/>\n",numEl_BRAHMS);
				}
				fprintf(g_ampaLOGREPORT,"		<TimeStep dt=\"%f\"/>\n", dt);
				fprintf(g_ampaLOGREPORT, "	</AnalogLog>\n");
				fprintf(g_ampaLOGREPORT, "</LogReport>\n");

				fclose(g_ampaLOGREPORT);
				fclose(g_ampaLOGFILE);
			}

			// Write variable name: g_ampa into a file.
			{
				unsigned char copy_buffer_BRAHMS[1024] = "";
				FILE* g_ampa_svfile;
				string g_ampa_fileName = g_ampa_BINARY_FILE_NAME_OUT;
#ifdef MAKE_BACKUP_OF_ORIGINAL_STATE
				g_ampa_svfile = fopen (g_ampa_fileName.c_str(), "rb");
				if (g_ampa_svfile) {

					string g_ampa_fileName_backup = g_ampa_fileName + ".bu";
					FILE* g_ampa_svfile_backup;
					g_ampa_svfile_backup = fopen (g_ampa_fileName_backup.c_str(), "wb");
					if (!g_ampa_svfile) {
						berr << "Could not open state variable backup file: " << g_ampa_fileName_backup;
					}

					size_t bytes_copied_BRAHMS = 0;
					size_t bytes_really_copied = 0;
					while ((bytes_copied_BRAHMS = fread (copy_buffer_BRAHMS, 1, 1024, g_ampa_svfile)) > 0) {
						bytes_really_copied = fwrite (copy_buffer_BRAHMS, 1, bytes_copied_BRAHMS, g_ampa_svfile_backup);
						if (bytes_really_copied != bytes_copied_BRAHMS) {
							berr << "Error making state variable backup file: " << g_ampa_fileName_backup;
						}
					}
					fclose (g_ampa_svfile_backup);
					fclose (g_ampa_svfile);
				}
#endif
				g_ampa_svfile = fopen (g_ampa_fileName.c_str(), "wb");
				if (!g_ampa_svfile) {
					berr << "Could not open state variable file: " << g_ampa_fileName;
				}

				int writertn_BRAHMS = 0, writeiter_BRAHMS = 0;
				while (writeiter_BRAHMS < this->g_ampa.size()) {
					writertn_BRAHMS = fwrite (reinterpret_cast<const char*>(&writeiter_BRAHMS), sizeof(int), 1, g_ampa_svfile);
					if (writertn_BRAHMS != 1) {
						berr << "Failed to write index into " << g_ampa_fileName << ". Wrote " << writertn_BRAHMS << " ints, rather than 1";
					}
					writertn_BRAHMS = fwrite (reinterpret_cast<const char*>(&this->g_ampa[writeiter_BRAHMS]), sizeof(double), 1, g_ampa_svfile);
					if (writertn_BRAHMS != 1) {
						berr << "Failed to write data into " << g_ampa_fileName << ". Wrote " << writertn_BRAHMS << " doubles, rather than 1";
					}
					++writeiter_BRAHMS;
				}

				fclose (g_ampa_svfile);
			}

			// Write variable name: buffer into a file.
			{
				unsigned char copy_buffer_BRAHMS[1024] = "";
				FILE* buffer_svfile;
				string buffer_fileName = buffer_BINARY_FILE_NAME_OUT;
#ifdef MAKE_BACKUP_OF_ORIGINAL_STATE
				buffer_svfile = fopen (buffer_fileName.c_str(), "rb");
				if (buffer_svfile) {

					string buffer_fileName_backup = buffer_fileName + ".bu";
					FILE* buffer_svfile_backup;
					buffer_svfile_backup = fopen (buffer_fileName_backup.c_str(), "wb");
					if (!buffer_svfile) {
						berr << "Could not open state variable backup file: " << buffer_fileName_backup;
					}

					size_t bytes_copied_BRAHMS = 0;
					size_t bytes_really_copied = 0;
					while ((bytes_copied_BRAHMS = fread (copy_buffer_BRAHMS, 1, 1024, buffer_svfile)) > 0) {
						bytes_really_copied = fwrite (copy_buffer_BRAHMS, 1, bytes_copied_BRAHMS, buffer_svfile_backup);
						if (bytes_really_copied != bytes_copied_BRAHMS) {
							berr << "Error making state variable backup file: " << buffer_fileName_backup;
						}
					}
					fclose (buffer_svfile_backup);
					fclose (buffer_svfile);
				}
#endif
				buffer_svfile = fopen (buffer_fileName.c_str(), "wb");
				if (!buffer_svfile) {
					berr << "Could not open state variable file: " << buffer_fileName;
				}

				int writertn_BRAHMS = 0, writeiter_BRAHMS = 0;
				while (writeiter_BRAHMS < this->buffer.size()) {
					writertn_BRAHMS = fwrite (reinterpret_cast<const char*>(&writeiter_BRAHMS), sizeof(int), 1, buffer_svfile);
					if (writertn_BRAHMS != 1) {
						berr << "Failed to write index into " << buffer_fileName << ". Wrote " << writertn_BRAHMS << " ints, rather than 1";
					}
					writertn_BRAHMS = fwrite (reinterpret_cast<const char*>(&this->buffer[writeiter_BRAHMS]), sizeof(double), 1, buffer_svfile);
					if (writertn_BRAHMS != 1) {
						berr << "Failed to write data into " << buffer_fileName << ". Wrote " << writertn_BRAHMS << " doubles, rather than 1";
					}
					++writeiter_BRAHMS;
				}

				fclose (buffer_svfile);
			}


			//	ok
			return C_OK;
		}

	}


	//	if we service the event, we return C_OK
	//	if we don't, we should return S_NULL to indicate that we didn't
	return S_NULL;
}







//	include the second part of the overlay (it knows you've included it once already)
#include "brahms-1199.h"
